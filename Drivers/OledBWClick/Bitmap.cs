/*
 * OLED W/B Click board driver.
 *  - This driver can be used for the OLED W or OLED B Click boards by MikroE.
 * Version 1.0 :
 *  - Initial version coded by Stephen Cardinale
 * 
 * References needed :
 *  Microsoft.SPOT.Hardware
 *  Microsoft.SPOT.Native
 *  MikroBusNet
 *  mscorlib
 *  
 * Copyright 2014 MikroBus.Net
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

using System;

namespace MBN.Modules
 {
    /// <summary>
    /// Abstracts a 1 bit depth bitmap expressed as a flat array of 8 bit values.
    /// </summary>
    public class Bitmap
	{
	    private static byte[] _bitmapData;
	    private static int _width;
	    private static int _height;

		/// <summary>
		/// A Abstract monochrome bitmap object that is usable by the drawing methods of the OLEDWB Click.
		/// </summary>
		/// <param name="data">An array of bytes representing the actual bitmap data.</param>
		/// <param name="widthInPixels">Width of the bitmap object in pixels.</param>
		/// <param name="heightInPixels">Height of the bitmap object in pixels.</param>
        public Bitmap(byte[] data, int widthInPixels, int heightInPixels) 
		{
            if ((heightInPixels % 8) != 0 || (widthInPixels % 8) != 0) { throw new ArgumentException("height and width must be multiples of 8"); }
            if (data.Length != heightInPixels * widthInPixels / 8) { throw new ArgumentException("Data must be consistent with width and height.", "data"); }

            _width = widthInPixels;
            _height = heightInPixels;
			_bitmapData = data;
        }

        /// <summary>
        /// Gets the Width of the bitmap in pixels
        /// </summary>
        public int Width { get { return _width; } }

        /// <summary>
        /// Gets the Height of the bitmap in pixels
        /// </summary>
        public int Height { get { return _height; } }

		/// <summary>
		/// An array of bytes representing the actual bitmap data.
		/// </summary>
		public byte[] BitmapDataBytes { get { return _bitmapData; } }

		/// <summary>
		/// Parses a valid bitmap object usable by the OLEDWB Click from a file or embedded resource generated by LCDAssistant.
		/// LCDAssistant can be obtained from <see href="http://en.radzio.dxp.pl"/>LCDAssistant/>.
		/// </summary>
		/// <param name="imageDataFromResource">A string containing the monochrome bitmap data.</param>
		/// <returns>A <see cref="Bitmap"/> object usable by the drawing methods of the <see cref="OLEDWBClick"/> class.</returns>
		/// <remarks>Be sure to include the size information in the generated file by checking the "Include size" check box and to select the Little Edianness Radio Button </remarks>
		public static Bitmap Parse(string imageDataFromResource)
		{
			// Remove the header information.
			int start = imageDataFromResource.IndexOf('{');
			var trimmed = imageDataFromResource.Substring(start + 1, 24).TrimEnd(new[] { '\n', '\r' });

			// Find the image dimensions.
			string[] splitString = trimmed.Split(new[] { ',' });

			if (splitString.Length != 4) throw new NotImplementedException("Resource information does not contain the image dimensions.");
			var pixelWidth = Convert.ToInt32(splitString[0].TrimStart(new[] { '\r', '\n' }).TrimEnd(new[] { '\n', '\r' }), 16);
			var pixelHeight = Convert.ToInt32(splitString[2].TrimStart(new[] { '\n', '\r' }).TrimEnd(new[] { '\n', '\r' }), 16);

			// Parse the image data bytes and return a Bitmap.
			trimmed = imageDataFromResource.Substring(start + 26, imageDataFromResource.Length - start - 26).Trim().TrimEnd('}', ';');
			splitString = trimmed.Split(new[] { ',' });
			var returnBytes = new byte[splitString.Length];

			for (var x = 0; x < returnBytes.Length; x++)
			{
				returnBytes[x] = (byte)Convert.ToInt32(splitString[x].TrimStart(new[] { '\n', '\r' }).TrimEnd(new[] { '\n', '\r' }), 16);
			}

			return new Bitmap(returnBytes, pixelWidth, pixelHeight);
		}

    }
}
